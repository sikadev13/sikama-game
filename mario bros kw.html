<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Fantasy Castle — Pipa GotoLevel + Ultimate H</title>
<style>
  html,body{margin:0;height:100%;background:#071022;font-family:Inter,system-ui,Arial;overflow:hidden;-webkit-tap-highlight-color:transparent}
  #app{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(#8fd1ff,#6ac4ff);image-rendering:pixelated}
  #hud{position:fixed;top:8px;left:10px;color:#fff;font-weight:700;text-shadow:1px 1px 0 #000;z-index:60;font-size:14px;pointer-events:none}
  #controlsUI{position:fixed;top:8px;right:10px;z-index:70;display:flex;gap:8px}
  .uiBtn{background:rgba(0,0,0,0.45);color:#fff;border:0;padding:6px 8px;border-radius:6px;cursor:pointer;font-weight:700}
  #message{position:fixed;left:50%;transform:translateX(-50%);bottom:10px;background:rgba(0,0,0,0.55);color:#fff;padding:8px 12px;border-radius:6px;font-weight:600;z-index:60}
  #overlayStart{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.66);z-index:200;color:#fff;flex-direction:column;gap:12px;padding:18px;touch-action:none}
  #youWin{position:fixed;top:14%;left:50%;transform:translateX(-50%);font-size:64px;color:gold;font-weight:900;text-shadow:6px 6px 0px #000;opacity:0;z-index:151;pointer-events:none}
  @media (max-width:520px){ #youWin{font-size:40px} #hud{font-size:12px} }
  #mobileControls{position:fixed;left:10px;right:10px;bottom:10px;display:none;justify-content:space-between;z-index:90;pointer-events:none}
  .touchBtn{pointer-events:auto;background:rgba(0,0,0,0.45);color:#fff;padding:10px;border-radius:10px;min-width:64px;text-align:center;font-weight:700}
  /* overlay flash for ultimate */
  #ultimateFlash{position:fixed;inset:0;background:#ffffff;border-radius:0;opacity:0;pointer-events:none;z-index:300;mix-blend-mode:screen}
</style>
</head>
<body>
<div id="app"><canvas id="game"></canvas></div>

<div id="hud">LEVEL: <span id="level">1</span> | COINS: <span id="coin">0</span> | HP: <span id="hp">3</span> | FLIGHT: <span id="flight">100</span></div>
<div id="controlsUI">
  <button id="restartBtn" class="uiBtn">⟳ Restart</button>
  <label style="display:flex;align-items:center;gap:6px;color:#fff;font-weight:700">
    <input type="checkbox" id="lowParticles"> Hemat Partikel
  </label>
</div>

<div id="message">Pilih mode lalu mulai permainan.</div>

<div id="overlayStart" role="dialog" aria-modal="true">
  <div style="text-align:center;max-width:520px">
    <div style="font-size:22px;font-weight:900">Fantasy Castle — Pipa & Ultimate</div>
    <div style="margin-top:8px;opacity:0.95">Tekan ↓ (S) saat berdiri di pipa untuk masuk. Tekan H untuk Ultimate (mengalahkan Emperor Void satu pukulan).</div>
    <div style="display:flex;gap:10px;justify-content:center;margin-top:12px">
      <div class="uiBtn" id="autoBtn">Auto</div>
      <div class="uiBtn" id="desktopBtn">Komputer</div>
      <div class="uiBtn" id="mobileBtn">Handphone</div>
    </div>
  </div>
</div>

<div id="youWin">YOU WIN!</div>
<div id="ultimateFlash"></div>

<div id="mobileControls">
  <div style="display:flex;gap:8px">
    <div class="touchBtn" id="btnLeft">◀</div>
    <div class="touchBtn" id="btnRight">▶</div>
  </div>
  <div style="display:flex;gap:8px">
    <div class="touchBtn" id="btnJump">Lompat</div>
    <div class="touchBtn" id="btnFire">Serang</div>
  </div>
</div>

<script>
/* Lengkap: pipa dengan exitX/exitY, pipa gotoLevel, animasi masuk/keluar, indikasi pipa,
   dan Ultimate (H) yang membunuh Emperor Void (level 10 -> index 9) dengan satu pukulan.
*/

// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const MAX_DPR = 2;
let DPR = Math.max(1, Math.min(MAX_DPR, window.devicePixelRatio || 1));
let CSS_W = Math.max(360, window.innerWidth);
let CSS_H = Math.max(240, window.innerHeight);
let W = CSS_W, H = CSS_H;
function resizeCanvas(){
  DPR = Math.max(1, Math.min(MAX_DPR, window.devicePixelRatio || 1));
  CSS_W = Math.max(360, window.innerWidth); CSS_H = Math.max(240, window.innerHeight);
  canvas.width = Math.round(CSS_W * DPR); canvas.height = Math.round(CSS_H * DPR);
  canvas.style.width = CSS_W + 'px'; canvas.style.height = CSS_H + 'px';
  ctx.setTransform(DPR,0,0,DPR,0,0); ctx.imageSmoothingEnabled = false;
  W = CSS_W; H = CSS_H;
}
window.addEventListener('resize', ()=> setTimeout(resizeCanvas, 80));
resizeCanvas();

// Input
let keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// Touch bindings
const touchState = { left:false, right:false, jump:false, fire:false, down:false };
function bindTouch(id, field){
  const el = document.getElementById(id); if(!el) return;
  el.addEventListener('touchstart', ev => { ev.preventDefault(); touchState[field] = true; }, {passive:false});
  el.addEventListener('touchend', ev => { ev.preventDefault(); touchState[field] = false; }, {passive:false});
  el.addEventListener('mousedown', ev => { ev.preventDefault(); touchState[field] = true; });
  el.addEventListener('mouseup', ev => { ev.preventDefault(); touchState[field] = false; });
}
bindTouch('btnLeft','left'); bindTouch('btnRight','right'); bindTouch('btnJump','jump'); bindTouch('btnFire','fire');

// Micro SFX
let audioCtx = null;
function ensureAudio(){ if(!audioCtx){ try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; } } }
function sfx(type){
  if(!audioCtx) return;
  try{
    const now = audioCtx.currentTime; const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    if(type==='shoot'){ o.type='square'; o.frequency.setValueAtTime(900, now); g.gain.setValueAtTime(0.12, now); o.frequency.exponentialRampToValueAtTime(400, now+0.12); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18); }
    else if(type==='hit'){ o.type='sawtooth'; o.frequency.setValueAtTime(380, now); g.gain.setValueAtTime(0.15, now); o.frequency.exponentialRampToValueAtTime(140, now+0.14); g.gain.exponentialRampToValueAtTime(0.0001, now+0.22); }
    else if(type==='pipe'){ o.type='sine'; o.frequency.setValueAtTime(600, now); g.gain.setValueAtTime(0.08, now); o.frequency.exponentialRampToValueAtTime(320, now+0.24); g.gain.exponentialRampToValueAtTime(0.0001, now+0.36); }
    else if(type==='victory'){ o.type='triangle'; o.frequency.setValueAtTime(900, now); g.gain.setValueAtTime(0.08, now); o.frequency.exponentialRampToValueAtTime(600, now+0.14); g.gain.exponentialRampToValueAtTime(0.0001, now+0.6); }
    else if(type==='ultimate'){ o.type='sawtooth'; o.frequency.setValueAtTime(1200, now); g.gain.setValueAtTime(0.18, now); o.frequency.exponentialRampToValueAtTime(300, now+0.32); g.gain.exponentialRampToValueAtTime(0.0001, now+0.6); }
    o.start(now); o.stop(now+0.7);
  } catch(e){}
}

// Background & levels
const BG = [
  {top:'#8fd1ff',bottom:'#6ac4ff',par:'#a7e0b8'}, {top:'#cfe9ff',bottom:'#8fd1ff',par:'#b1d9a0'}, {top:'#9fb6c6',bottom:'#5f9fb1',par:'#2f7b4a'},
  {top:'#ffb49a',bottom:'#ff7a7a',par:'#d98c5a'}, {top:'#ffe29a',bottom:'#ffd86b',par:'#caa24a'}, {top:'#6b9bd9',bottom:'#2b4f6f',par:'#6a4f2a'},
  {top:'#cfe8ff',bottom:'#9fd3ff',par:'#9ad8ff'}, {top:'#ff9a6b',bottom:'#6b1a1a',par:'#8f3b1a'}, {top:'#dfefff',bottom:'#b2d8ff',par:'#cfe6ff'},
  {top:'#0b1220',bottom:'#041026',par:'#2b4b9a'}
];

const LEVELS = [];
for(let i=0;i<10;i++){
  const w = 1400 + i*150;
  const goal = w - 120;
  const baseY = 480;
  const platforms = [{x:0,y:baseY,w:w,h:60,type:'ground'}];
  for(let p=0;p<Math.min(3,Math.floor((i+1)/2)+1);p++){
    platforms.push({x:240 + p*280 + i*40, y:baseY - 110 - p*36, w:140, h:20, type:'platform'});
  }
  const coins=[]; for(let c=0;c<3;c++) coins.push({x:300 + c*240 + i*30, y: baseY - 60 - (c%2)*42});
  const crystals = (i%2===0) ? [{x:620 + i*20, y: baseY - 150}] : [];
  const enemies = [{x:520 + i*60, y: baseY - 40, dir: (i%2===0?1:-1)}];
  let pipes = [];
  // level 1: internal teleport and gotoLevel example
  if(i === 0){
    pipes.push({ x: 700, y: 480 - 44, w: 64, h:44, exitX: 920, exitY: 480 - 48 }); // same-level teleport
    pipes.push({ x: 1100, y: 480 - 44, w: 64, h:44, gotoLevel: 2 }); // pipe that sends to level 3 (index 2)
  }
  if(i === 2){
    pipes.push({ x: 980, y: 480 - 44, w: 64, h:44, exitX: 1180, exitY: 480 - 48 });
  }
  if(i === 7){
    pipes.push({ x: 1100, y: 480 - 44, w: 64, h:44, exitX: 1400, exitY: 480 - 48 });
  }
  // final level (index 9) has boss — Emperor Void
  LEVELS.push({ width:w, spawn:{x:80,y:400}, platforms, coins, crystals, enemies, goalX:goal, pipes });
}

// Global state
let levelIndex = 0;
let worldWidth = LEVELS[levelIndex].width;
let blocks = [], items = [], enemies = [], fireballs = [];
let player = { x:100, y:0, w:36, h:48, vx:0, vy:0, ax:0, speed:0.45, maxSpeed:5, friction:0.82, jumpPower:11, onGround:false, hp:3, facing:1, jumps:0, maxJumps:3, flight:100, canShoot:false, shootCooldown:0, frozen:false };
let castle = { x: worldWidth + 800, y:240, w:420, h:260 };
const bosses = { 4:{name:'Golem King', baseHp:14, size:76, color:'#8b6a3a'}, 9:{name:'Emperor Void', baseHp:24, size:96, color:'#1f2a66'} };
let boss = { active:false, hp:0, x:0, y:0, w:0, h:0, alive:false, dead:false, deadStart:0, fireCooldown:120, shake:0, flash:0 };

// victory (initialized)
let victory = { started:false, stage:0, startTime:0, flag:{ x: castle.x + 320, poleHeight:140, flagY: castle.y + 200, flagTargetY: castle.y + 150, raised:false }, playerMovedToFlag:false, playerMovedToPrincess:false, hugStartTime:null, hugDuration:1800, celebrationStarted:false };

let coins = 0, cameraX = 0, gravity = 0.6;
let confetti = [], LOW_PARTICLES = true, CONFETTI_MAX = 100;
let inTransition = false, transitionStart = 0, transitionDuration = 900;

// Pipe animation state
let pipeState = { active:false, phase:null, startTime:0, duration:0, pipe:null, origin:{x:0,y:0}, dest:{x:0,y:0}, isGoto:false, gotoLevel:null };

// Ultimate state (H)
let ultimateUsed = false;

// HUD
function updateHUD(force){ if(force || document.getElementById('level').textContent != (levelIndex+1)) document.getElementById('level').textContent = levelIndex+1; document.getElementById('coin').textContent = coins; document.getElementById('hp').textContent = player.hp; document.getElementById('flight').textContent = Math.round(player.flight); }

// Load level (including pipes)
function loadLevel(idx){
  levelIndex = Math.max(0, Math.min(idx, LEVELS.length-1));
  const L = LEVELS[levelIndex];
  worldWidth = L.width;
  blocks = []; items = []; enemies = []; fireballs = [];
  if(L.platforms) for(const p of L.platforms) blocks.push({...p});
  if(L.coins) for(const c of L.coins) items.push({type:'coin', x:c.x, y:c.y, w:28, h:28, collected:false});
  if(L.crystals) for(const c of L.crystals) items.push({type:'crystal', x:c.x, y:c.y, w:30, h:36, collected:false});
  if(L.enemies) for(const e of L.enemies) enemies.push({type:'goomba', x:e.x, y:e.y, w:36, h:36, vx:e.dir||-1, alive:true});
  player.x = L.spawn.x; player.y = L.spawn.y; player.vx = player.vy = 0; player.jumps = 0; player.onGround = false; player.canShoot = false; player.shootCooldown = 0; player.flight = 100; player.frozen = false;
  castle.x = worldWidth + 800;
  boss = { active:false, hp:0, x:0, y:0, w:0, h:0, alive:false, dead:false, deadStart:0, fireCooldown:120, shake:0, flash:0 };
  victory = { started:false, stage:0, startTime:0, flag:{ x: castle.x + 320, poleHeight:140, flagY: castle.y + 200, flagTargetY: castle.y + 150, raised:false }, playerMovedToFlag:false, playerMovedToPrincess:false, hugStartTime:null, hugDuration:1800, celebrationStarted:false };
  pipeState = { active:false, phase:null, startTime:0, duration:0, pipe:null, origin:{x:0,y:0}, dest:{x:0,y:0}, isGoto:false, gotoLevel:null };
  // reset ultimate each new playthrough (but keep if you want persistent)
  ultimateUsed = false;
  updateHUD(true);
}
loadLevel(0);

// collision helper
function collide(a,b){ return a && b && a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

// Pipe helper: check if player stands on pipe-top
function playerOnPipeTop(pipe){
  const pxCenter = player.x + player.w/2;
  const withinX = pxCenter >= pipe.x + 6 && pxCenter <= pipe.x + pipe.w - 6;
  const bottomY = player.y + player.h;
  const onTop = Math.abs(bottomY - pipe.y) <= 1.6;
  return withinX && onTop;
}

// Activate boss helper
function activateBossForLevel(idx){
  const def = bosses[idx];
  if(!def) return;
  boss.active = true; boss.alive = true; boss.dead = false;
  boss.hp = def.baseHp; boss.x = castle.x + 180; boss.y = castle.y + 90; boss.w = def.size; boss.h = def.size; boss.fireCooldown = 120; boss.color = def.color; document.getElementById('message').textContent = def.name + ' muncul!'; ensureAudio(); sfx('hit');
  setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },2400);
}

// Confetti
function spawnConfetti(x,y,count=30){
  const actual = LOW_PARTICLES ? Math.min(10, Math.floor(count/3)) : count;
  for(let i=0;i<actual;i++){
    confetti.push({ x:x + (Math.random()-0.5)*80, y:y + (Math.random()-0.5)*40, dx:(Math.random()-0.5)*2.4, dy:- (1 + Math.random()*2.4), life:60 + Math.floor(Math.random()*80), color:`hsl(${Math.floor(Math.random()*360)},80%,60%)` });
    if(confetti.length > CONFETTI_MAX) confetti.splice(0, confetti.length - CONFETTI_MAX);
  }
}

// Start pipe animation sequence
function startPipeEnter(pipe){
  if(pipeState.active) return;
  ensureAudio(); sfx('pipe');
  pipeState.active = true;
  pipeState.pipe = pipe;
  pipeState.phase = 'in';
  pipeState.startTime = performance.now();
  pipeState.duration = 420; // ms to sink
  pipeState.origin = { x: player.x, y: player.y };
  pipeState.dest = { x: (typeof pipe.exitX === 'number' ? Math.min(Math.max(0, pipe.exitX), worldWidth - player.w) : player.x), y: (typeof pipe.exitY === 'number' ? pipe.exitY : player.y) };
  pipeState.isGoto = typeof pipe.gotoLevel === 'number';
  pipeState.gotoLevel = pipe.gotoLevel;
  player.frozen = true;
}

// Draw helpers for pipe indicators
function drawPipeIndicator(pipe, tnow){
  // pulse value
  const pulse = (Math.sin(tnow/280 + pipe.x*0.01) + 1) * 0.5; // 0..1
  const rimAlpha = 0.25 + pulse*0.5;
  // glowing rim above top
  ctx.save();
  ctx.globalAlpha = rimAlpha;
  ctx.fillStyle = '#64f05b';
  ctx.fillRect(pipe.x - 6, pipe.y - 12 - 2, pipe.w + 12, 8);
  ctx.restore();
  // floating arrow above
  const arrowY = pipe.y - 24 - Math.sin(tnow/300 + pipe.x*0.02)*6;
  ctx.save();
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = '#fff';
  ctx.font = '18px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('↓', pipe.x + pipe.w/2, arrowY);
  ctx.restore();
}

// Ultimate: H
function doUltimate(){
  if(ultimateUsed) { document.getElementById('message').textContent = 'Ultimate sudah dipakai.'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; }, 900); return; }
  if(!boss.active || !boss.alive){ document.getElementById('message').textContent = 'Tidak ada musuh besar saat ini.'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; }, 900); return; }
  // Only works as one-shot to Emperor Void (levelIndex === 9) per user request
  if(levelIndex === 9){
    ultimateUsed = true;
    ensureAudio(); sfx('ultimate');
    // big flash
    const flash = document.getElementById('ultimateFlash'); flash.style.transition = 'none'; flash.style.opacity = '0.95';
    setTimeout(()=>{ flash.style.transition = 'opacity 700ms ease'; flash.style.opacity = '0'; }, 120);
    // kill boss instantly and start victory
    boss.hp = 0;
    document.getElementById('message').textContent = 'Ultimate Strike! Emperor Void hancur!';
    startVictorySequence();
    // visual boss death: set dead immediately
    boss.dead = true; boss.deadStart = performance.now() - 1700; // fast-forward a bit to trigger victory flow
    setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; }, 1600);
  } else {
    // If user uses on non-final boss, just big damage
    ultimateUsed = true;
    ensureAudio(); sfx('ultimate');
    document.getElementById('message').textContent = 'Ultimate Strike — besar kerusakan!';
    if(boss.active && boss.alive){
      boss.hp = Math.max(0, boss.hp - 999);
      if(boss.hp <= 0) startVictorySequence();
    }
    setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; }, 1200);
  }
}

// Update loop
let last = performance.now();
function update(){
  const now = performance.now();
  const dt = now - last; last = now;

  try{
    // If pipe animation active, handle it separately (disables normal input & physics)
    if(pipeState.active){
      const t = Math.min(1, (now - pipeState.startTime) / pipeState.duration);
      if(pipeState.phase === 'in'){
        // animate sinking down a bit into pipe (y increases)
        const sinkAmount = (pipeState.pipe.h/2 + 8); // how deep visually
        player.x = pipeState.origin.x; // lock x while sinking
        player.y = pipeState.origin.y + sinkAmount * t;
        player.vx = player.vy = 0;
        // after sink finished -> teleport or gotoLevel then start 'out' after tiny delay
        if(t >= 1){
          if(pipeState.isGoto){
            // small UX: short pause then load target level
            document.getElementById('message').textContent = 'Memasuki pipa... memindahkan level...';
            setTimeout(()=>{
              loadLevel(pipeState.gotoLevel);
              document.getElementById('message').textContent = 'Level ' + (levelIndex+1) + '!';
              setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },900);
            }, 260);
            // finish animation immediately
            pipeState.active = false;
            player.frozen = false;
            return;
          } else {
            // teleport in same level
            player.x = pipeState.dest.x;
            const destY = (typeof pipeState.pipe.exitY === 'number') ? pipeState.dest.y : (pipeState.pipe.y - player.h + (pipeState.pipe.h/2));
            player.y = destY + Math.min(20, Math.max(8, pipeState.pipe.h/2));
            // small pause before emerging
            pipeState.phase = 'out';
            pipeState.startTime = now;
            pipeState.duration = 420;
            ensureAudio(); sfx('pipe');
          }
        }
      } else if(pipeState.phase === 'out'){
        // emerging: move player upward to sit exactly on top of pipe
        const destTopY = (typeof pipeState.pipe.exitY === 'number') ? pipeState.dest.y : (pipeState.pipe.y - player.h);
        const startY = player.y;
        const tt = Math.min(1, (now - pipeState.startTime) / pipeState.duration);
        const smooth = 1 - Math.pow(1 - tt, 2);
        player.y = startY * (1 - smooth) + destTopY * smooth;
        player.vx = player.vy = 0;
        if(tt >= 1){
          // finished
          pipeState.active = false;
          pipeState.phase = null;
          player.frozen = false;
          document.getElementById('message').textContent = 'Keluar dari pipa...';
          setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },900);
        }
      }
      updateHUD(false);
      return;
    }

    // Input & physics (normal flow)
    player.ax = 0;
    if((keys['arrowleft']||keys['a']||touchState.left) && !player.frozen){ player.ax = -player.speed; player.facing = -1; }
    if((keys['arrowright']||keys['d']||touchState.right) && !player.frozen){ player.ax = player.speed; player.facing = 1; }
    player.vx += player.ax;
    if(Math.abs(player.vx) > player.maxSpeed) player.vx = Math.sign(player.vx) * player.maxSpeed;
    if(player.ax === 0) player.vx *= player.friction;

    const jumpPressed = (keys[' ']||keys['w']||keys['arrowup']||touchState.jump) && !player.frozen;
    if(jumpPressed && !player._jumpDown){
      player._jumpDown = true;
      if(player.jumps < player.maxJumps){ player.vy = -player.jumpPower; player.jumps++; player.onGround = false; sfx('hit'); }
    }
    if(!jumpPressed) player._jumpDown = false;

    if(jumpPressed && !player.onGround && player.flight > 0 && player.canFly){ player.vy -= 0.45; player.flight -= 0.9; if(player.flight < 0) player.flight = 0; } else { if(player.onGround && player.flight < 100) player.flight = Math.min(100, player.flight + 0.6); }

    const firePressed = (keys['e'] || touchState.fire) && !player.frozen;
    if(firePressed && player.canShoot && player.shootCooldown <= 0 && fireballs.length < 8){
      fireballs.push({ x: player.facing>0 ? player.x + player.w : player.x - 12, y: player.y + 16, w:12, h:10, vx: player.facing>0 ? 6 : -6, alive:true });
      player.shootCooldown = 28; sfx('shoot');
    }
    if(player.shootCooldown > 0) player.shootCooldown--;

    player.vy += gravity; player.x += player.vx; player.y += player.vy;
    if(player.x < 0) player.x = 0; if(player.x + player.w > worldWidth) player.x = worldWidth - player.w;

    // collisions with blocks & pipe tops treated as ground
    player.onGround = false;
    for(let i=0;i<blocks.length;i++){
      const b = blocks[i];
      if(collide(player,b)){
        const prevBottom = player.y - player.vy + player.h;
        if(player.vy > 0 && prevBottom <= b.y){ player.y = b.y - player.h; player.vy = 0; player.onGround = true; player.jumps = 0; }
        else if(player.vy < 0 && player.y >= b.y + b.h){ player.y = b.y + b.h; player.vy = 1; if(b.type==='brick'){ blocks.splice(i,1); i--; } if(b.type==='question' && !b.used){ b.used = true; items.push({ type:'coin', x: b.x+6, y: b.y-30, w:28, h:28, vy:-7, timer:40, collected:false }); } }
        else { if(player.vx > 0) player.x = b.x - player.w; else player.x = b.x + b.w; player.vx = 0; }
      }
    }

    // also check pipes as ground: snap to top if above
    const pipesHere = (LEVELS[levelIndex] && LEVELS[levelIndex].pipes) ? LEVELS[levelIndex].pipes : [];
    for(const pipe of pipesHere){
      const playerBottom = player.y + player.h;
      const pxCenter = player.x + player.w/2;
      if(pxCenter >= pipe.x + 6 && pxCenter <= pipe.x + pipe.w - 6){
        if(playerBottom > pipe.y - 6 && playerBottom < pipe.y + 12 && player.vy >= 0){
          player.y = pipe.y - player.h;
          player.vy = 0; player.onGround = true; player.jumps = 0;
        }
      }
    }

    // items
    for(const it of items){ if(!it || it.collected) continue; if(it.timer){ it.y += it.vy; it.vy += 0.5; it.timer--; if(it.timer<=0) it.timer=0; } if(collide(player,it)){ if(it.type==='coin'){ coins++; it.collected=true; sfx('hit'); } if(it.type==='crystal'){ it.collected=true; player.canShoot=true; document.getElementById('message').textContent='Crystal collected — Fireball ready (E)!'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },1600); } if(it.type==='wing'){ it.collected=true; player.flight=100; document.getElementById('message').textContent='Flight restored!'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },1400); } } }

    // enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i]; if(!e||!e.alive){ enemies.splice(i,1); continue; }
      e.x += e.vx;
      for(const b of blocks) if(collide(e,b)) e.vx *= -1;
      if(collide(player,e)){ if(player.vy > 1){ e.alive=false; player.vy=-10; sfx('hit'); } else { player.hp--; document.getElementById('message').textContent='Kena musuh!'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },1200); if(player.hp<=0) loadLevel(levelIndex); } }
    }

    // fireballs
    for(let i=fireballs.length-1;i>=0;i--){
      const f = fireballs[i]; if(!f||!f.alive){ fireballs.splice(i,1); continue; }
      f.x += f.vx;
      for(let j=enemies.length-1;j>=0;j--){ const en = enemies[j]; if(!en||!en.alive) continue; if(collide(f,en)){ en.alive=false; f.alive=false; sfx('hit'); break; } }
      if(boss.alive && !boss.dead){
        const bx = boss.x + (boss.shake||0);
        const bowRect = { x: bx - boss.w/2, y: boss.y, w: boss.w, h: boss.h };
        if(collide(f,bowRect)){ boss.hp -= (levelIndex===9?1:2); f.alive=false; boss.flash = 220; sfx('hit'); document.getElementById('message').textContent = 'Boss terkena! HP: '+boss.hp; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },800); if(boss.hp<=0) startVictorySequence(); }
      }
      if(f.x < 0 || f.x > worldWidth) f.alive=false;
      if(!f.alive) fireballs.splice(i,1);
    }

    // boss AI
    if(boss.active && boss.alive && !boss.dead){
      const bx = boss.x;
      if(Math.abs(player.x - bx) > 80) boss.x += (player.x < bx ? -0.6 : 0.6);
      boss.fireCooldown--;
      if(boss.fireCooldown <= 0){
        boss.fireCooldown = levelIndex===9 ? 70 : 110;
        if(levelIndex===9){
          for(let k=-1;k<=1;k++) enemies.push({ type:'bossfire', x: boss.x - 10, y: boss.y + 20 + k*6, w:10, h:10, vx: (player.x < boss.x ? -3 + k : 3 + k), alive:true });
        } else {
          enemies.push({ type:'bossrock', x: boss.x - 10, y: boss.y + 20, w:14, h:14, vx: player.x < boss.x ? -3 : 3, alive:true });
        }
      }
      if(player.y + player.h < boss.y + 26 && player.vy > 1 && Math.abs(player.x - boss.x) < (boss.w/2 + 18)){ boss.hp-=1; player.vy=-12; sfx('hit'); if(boss.hp<=0) startVictorySequence(); }
      if(boss.flash > 0) boss.flash -= Math.min(16, now - (boss._lastFlash||now)); boss._lastFlash = now;
    }

    if(boss.dead){
      const elapsed = now - boss.deadStart;
      if(elapsed > 1600){
        boss.alive=false; boss.dead=false; boss.active=false;
        victory.started=true; victory.stage=1; victory.startTime=now;
        document.getElementById('message').textContent='Boss defeated! Raising flag...'; sfx('victory');
      }
    }

    // cleanup enemies
    for(let i=enemies.length-1;i>=0;i--){
      const e = enemies[i]; if(!e){ enemies.splice(i,1); continue; }
      if(e.type==='bossfire' || e.type==='bossrock'){ e.x += e.vx; e.y += 0.8; if(collide(e,player)){ player.hp--; e.alive=false; sfx('hit'); if(player.hp<=0) loadLevel(levelIndex); } if(e.x < 0 || e.x > worldWidth) e.alive=false; }
      if(!e.alive) enemies.splice(i,1);
    }

    // pipes: check enter input (ArrowDown or 's') when on top of pipe
    const pipesHere2 = (LEVELS[levelIndex] && LEVELS[levelIndex].pipes) ? LEVELS[levelIndex].pipes : [];
    const downPressed = keys['arrowdown'] || keys['s'] || touchState.down;
    for(const pipe of pipesHere2){
      if(playerOnPipeTop(pipe) && downPressed && !pipeState.active){
        startPipeEnter(pipe);
      }
    }

    // victory flows
    if(victory && victory.started){
      const tNow = performance.now();
      if(victory.stage === 1){
        const t = Math.min(1, (tNow - victory.startTime)/900);
        victory.flag.flagY = victory.flag.flagY*(1-t) + victory.flag.flagTargetY*t;
        if(t >= 1){ victory.flag.raised = true; victory.stage = 2; victory.startTime = tNow; document.getElementById('message').textContent = 'Go to the flag!'; }
      } else if(victory.stage === 2){
        if(!victory.playerMovedToFlag){
          const targetX = victory.flag.x - 48;
          player.x += (targetX - player.x) * 0.08;
          if(Math.abs(player.x - targetX) < 2){ victory.playerMovedToFlag = true; victory.startTime = tNow; document.getElementById('message').textContent = 'Flag reached. Proceed to Princess.'; }
        } else if(!victory.playerMovedToPrincess){
          if(tNow - victory.startTime > 600){
            const targetX = castle.x + 240;
            player.x += (targetX - player.x) * 0.06;
            if(Math.abs(player.x - targetX) < 3){ victory.playerMovedToPrincess = true; victory.stage = 3; victory.hugStartTime = tNow; document.getElementById('message').textContent = 'Hugging Princess...'; }
          }
        }
      } else if(victory.stage === 3){
        if(!victory.hugStartTime) victory.hugStartTime = performance.now();
        const elapsed = performance.now() - victory.hugStartTime;
        const progress = Math.min(1, elapsed / victory.hugDuration);
        if(progress >= 1){
          victory.stage = 4;
          document.getElementById('message').textContent = 'You rescued the Princess!';
          spawnConfetti(W/2 + cameraX, H/3, LOW_PARTICLES?40:120);
          document.getElementById('message').textContent = 'Perayaan dimulai!';
        }
      }
    }

    // camera follow
    if(!inTransition && !(victory && victory.started)){
      cameraX = player.x - W/2; if(cameraX < 0) cameraX = 0; if(cameraX > worldWidth - W) cameraX = worldWidth - W;
    }

    // progression to next level or castle
    const L = LEVELS[levelIndex];
    if(!victory.started && levelIndex < LEVELS.length && player.x >= L.goalX - 20){
      if(levelIndex < LEVELS.length - 1){
        levelIndex++; loadLevel(levelIndex); document.getElementById('message').textContent = 'Level ' + (levelIndex+1) + ' started!'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },1200);
      } else {
        // final: expand world & activate final boss
        castle.x = worldWidth + 380;
        activateBossForLevel(levelIndex);
        const tile = 64;
        for(let x = Math.floor(worldWidth / tile) * tile; x < castle.x + castle.w + 160; x+=tile){
          if(!blocks.some(b => Math.abs(b.x - x) < 1 && b.h === 60)) blocks.push({ x:x, y:480, w:tile, h:60, type:'ground' });
        }
        inTransition = true; transitionStart = performance.now();
      }
    }

    updateHUD(false);

  } catch(err){
    console.error('Update error', err);
    document.getElementById('message').textContent = 'Update error: ' + (err.message || err);
  }
}

// Draw
function drawBackground(){
  const p = BG[Math.min(levelIndex, BG.length-1)];
  const g = ctx.createLinearGradient(cameraX,0,cameraX+W,0);
  g.addColorStop(0,p.top); g.addColorStop(1,p.bottom); ctx.fillStyle = g; ctx.fillRect(cameraX,0,W,H);
  ctx.fillStyle = p.par;
  for(let i=0;i<8;i++){ const x = (i*290 - (cameraX*0.12 % 290)); ctx.fillRect(x, 270 + (i%2)*28, 80, 180); }
  if(inTransition || levelIndex >= LEVELS.length){ ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.fillRect(cameraX,0,W,H); }
}

function draw(){
  try{
    ctx.clearRect(0,0,W,H); ctx.save(); ctx.translate(-cameraX,0);
    drawBackground();

    // blocks
    for(const b of blocks){ if(b.x + b.w < cameraX - 80 || b.x > cameraX + W + 80) continue; ctx.fillStyle = (b.type==='ground')? '#6a8f3a' : '#7f5f3a'; ctx.fillRect(b.x,b.y,b.w,b.h); }

    // draw pipes (body + rim + inner) and indicators
    const pipesHere = (LEVELS[levelIndex] && LEVELS[levelIndex].pipes) ? LEVELS[levelIndex].pipes : [];
    const tnow = performance.now();
    for(const pipe of pipesHere){
      // pipe body
      ctx.fillStyle = '#1e8a2e';
      ctx.fillRect(pipe.x, pipe.y, pipe.w, pipe.h);
      // pipe rim (top)
      const near = Math.abs((player.x + player.w/2) - (pipe.x + pipe.w/2)) < 140 && Math.abs(player.y - pipe.y) < 120;
      ctx.fillStyle = near ? '#3eea55' : '#2fbf3e';
      ctx.fillRect(pipe.x - 4, pipe.y - 10, pipe.w + 8, 12);
      // inner black hole (slightly inset)
      ctx.fillStyle = '#041026';
      ctx.fillRect(pipe.x + 6, pipe.y + 6, pipe.w - 12, pipe.h - 12);
      // little pattern
      ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(pipe.x + pipe.w - 18, pipe.y + 8, 6, 8);

      // draw indicator above pipe (always)
      drawPipeIndicator(pipe, tnow);

      // small text for gotoLevel pipes
      if(typeof pipe.gotoLevel === 'number'){
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = '11px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('→ Lv ' + (pipe.gotoLevel+1), pipe.x + pipe.w/2, pipe.y - 34);
        ctx.restore();
      }
    }

    // items
    for(const it of items){ if(it.collected) continue; if(it.x + it.w < cameraX - 80 || it.x > cameraX + W + 80) continue; if(it.type === 'coin'){ ctx.fillStyle='#ffdf57'; ctx.fillRect(it.x,it.y,it.w,it.h); } else if(it.type === 'crystal'){ ctx.fillStyle='#9ff'; ctx.fillRect(it.x,it.y,it.w,it.h); } else { ctx.fillStyle='#fff'; ctx.fillRect(it.x,it.y,it.w,it.h); } }

    // enemies
    for(const e of enemies){ if(e.x + e.w < cameraX - 80 || e.x > cameraX + W + 80) continue; if(e.type === 'bossfire' || e.type === 'bossrock'){ ctx.fillStyle = '#f66'; ctx.fillRect(e.x,e.y,e.w,e.h); } else { ctx.fillStyle = '#b33'; ctx.fillRect(e.x,e.y,e.w,e.h); ctx.fillStyle='#000'; ctx.fillRect(e.x+6,e.y+8,6,6);} }

    // fireballs
    for(const f of fireballs){ if(f.x + f.w < cameraX - 80 || f.x > cameraX + W + 80) continue; ctx.fillStyle='#ff944d'; ctx.fillRect(f.x,f.y,f.w,f.h); }

    // castle
    if(levelIndex >= LEVELS.length){ ctx.fillStyle='#6b3b1a'; ctx.fillRect(castle.x,castle.y,castle.w,castle.h); ctx.fillStyle='#222'; ctx.fillRect(castle.x+120,castle.y,26,castle.h); }

    // boss shapes
    if(boss.active && (boss.alive || boss.dead)){
      const bx = boss.x + (boss.shake||0);
      if(levelIndex === 4){
        ctx.save(); ctx.globalAlpha = boss.flash>0 ? 0.9 : 1.0; ctx.fillStyle = bosses[4].color; ctx.fillRect(bx - boss.w/2, boss.y, boss.w, boss.h); ctx.fillStyle = '#000'; ctx.fillRect(bx - boss.w/2 + 12, boss.y + 18, 12, 12); ctx.fillRect(bx + boss.w/2 - 26, boss.y + 18, 12, 12); ctx.restore();
      } else if(levelIndex === 9){
        ctx.save(); ctx.globalAlpha = boss.flash>0 ? 0.9 : 1.0; ctx.fillStyle = bosses[9].color; ctx.beginPath(); ctx.ellipse(bx, boss.y + boss.h/2, boss.w/2, boss.h/2, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#2a6fff'; ctx.lineWidth = 4; ctx.beginPath(); ctx.ellipse(bx, boss.y + boss.h/2, boss.w/2 + 14, boss.h/2 + 16, 0, 0, Math.PI*2); ctx.stroke(); ctx.restore();
        // label to show Emperor Void
        ctx.save(); ctx.fillStyle='#fff'; ctx.font='14px monospace'; ctx.textAlign='center'; ctx.fillText('Emperor Void', bx, boss.y - 12); ctx.restore();
      }
    }

    // princess (rectangle) if rescued stage >=2
    if(victory && (victory.stage >= 2 || victory.playerMovedToPrincess)){ ctx.fillStyle = '#ffd'; ctx.fillRect(castle.x + 320, castle.y + 40, 28, 42); ctx.fillStyle='#f9c'; ctx.fillRect(castle.x + 324, castle.y + 46, 20, 12); }

    // player rectangle (if pipe animation active, we still draw player at animated position)
    if(pipeState.active && pipeState.phase === 'in'){
      const tt = Math.min(1, (performance.now() - pipeState.startTime) / pipeState.duration);
      const scaleY = 1 - 0.12 * tt;
      ctx.save();
      ctx.translate(player.x + player.w/2, player.y + player.h/2);
      ctx.scale(1, scaleY);
      ctx.fillStyle = '#4cf'; ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
      ctx.fillStyle = '#000'; ctx.fillRect((player.facing===1 ? 8 - player.w/2 : player.w/2 - 14), -player.h/2 + 12, 6, 6);
      ctx.restore();
    } else {
      ctx.fillStyle = '#4cf'; ctx.fillRect(player.x, player.y, player.w, player.h);
      ctx.fillStyle = '#000'; ctx.fillRect(player.x + (player.facing===1 ? 8 : player.w-14), player.y + 12, 6, 6);
    }

    // confetti overlay
    if(victory && victory.celebrationStarted){
      for(let i=confetti.length-1;i>=0;i--){
        const c = confetti[i]; ctx.fillStyle = c.color; ctx.fillRect(c.x, c.y, 4, 4); c.x += c.dx; c.y += c.dy; c.dy += 0.12; c.life--; if(c.life<=0) confetti.splice(i,1);
      }
    }

    ctx.restore();
  } catch(err){
    console.error('Draw error', err); document.getElementById('message').textContent = 'Rendering error: ' + (err.message || err);
  }
}

function startVictorySequence(){ if(victory && victory.started) return; if(victory) victory.started=true; if(boss) boss.dead=true; boss.deadStart = performance.now(); sfx('victory'); document.getElementById('message').textContent='Boss defeated!'; }

// Main loop
function mainLoop(){ update(); draw(); requestAnimationFrame(mainLoop); }

// Controls and UI
const overlay = document.getElementById('overlayStart');
const autoBtn = document.getElementById('autoBtn'), desktopBtn = document.getElementById('desktopBtn'), mobileBtn = document.getElementById('mobileBtn');
const mobileControls = document.getElementById('mobileControls');
function detectMode(){ const ua = navigator.userAgent || ''; return /android|iphone|ipad|mobile/i.test(ua.toLowerCase()) ? 'mobile' : 'desktop'; }
let MODE = null;
autoBtn.addEventListener('click', ()=>{ MODE = detectMode(); applyMode(); }, {passive:true});
desktopBtn.addEventListener('click', ()=>{ MODE = 'desktop'; applyMode(); }, {passive:true});
mobileBtn.addEventListener('click', ()=>{ MODE = 'mobile'; applyMode(); }, {passive:true});
function applyMode(){ overlay.style.display = 'none'; document.getElementById('message').textContent=''; ensureAudio(); audioCtx && audioCtx.resume && audioCtx.resume(); if(MODE==='mobile') mobileControls.style.display='flex'; else mobileControls.style.display='none'; mainLoop(); }
overlay.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(!MODE) MODE = detectMode(); applyMode(); }, {passive:false});

document.getElementById('restartBtn').addEventListener('click', ()=>{ loadLevel(levelIndex); document.getElementById('message').textContent='Restart level'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },900); });
document.getElementById('lowParticles').addEventListener('change', (e)=>{ LOW_PARTICLES = e.target.checked; CONFETTI_MAX = LOW_PARTICLES?60:150; });

window.addEventListener('keydown', e=>{
  const k = e.key.toLowerCase();
  if(k === 'r'){ loadLevel(levelIndex); document.getElementById('message').textContent = 'Restart level'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },900); }
  if(e.key === 'Enter' && victory && victory.started){ victory.stage = 4; victory.flag.flagY = victory.flag.flagTargetY; victory.playerMovedToFlag = true; victory.playerMovedToPrincess = true; victory.hugStartTime = null; document.getElementById('message').textContent='Cutscene skipped'; setTimeout(()=>{ if(document.getElementById('message')) document.getElementById('message').textContent=''; },900); }
  if(k === 's' || e.key === 'arrowdown'){ keys['s'] = keys['arrowdown'] = true; setTimeout(()=>{ keys['s']=keys['arrowdown']=false; }, 60); }
  if(k === 'h'){ // Ultimate use
    doUltimate();
  }
});

window.addEventListener('keyup', e=>{
  // normal keyup flows kept via global keys map
});

// init HUD
updateHUD(true);
LOW_PARTICLES = true;
console.log('Game ready: pipa gotoLevel + ultimate H enabled.');

/* Note:
 - Untuk menambah pipa yang berpindah level, beri properti gotoLevel pada LEVELS[i].pipes: {x,y,w,h,gotoLevel: N}
 - Untuk menambah teleport-in-level: gunakan exitX, exitY
 - Ultimate H hanya berlaku sebagai "one-shot" (ultimateUsed) dan akan membunuh Emperor Void di level index 9
*/
</script>
</body>
</html>
